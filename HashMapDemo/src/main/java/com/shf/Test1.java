package com.shf;

import java.util.HashMap;

/**
 * 1.当创建HashMap集合对象的时候，
 * 在jdk8之前，构造方法中创建一个长度是16的Entry[] table 用来存储键值对数据的
 * 在jdk8之后，不是在HashMap的构造方法底层创建数组了，是在第一次调用put方法是创建的数组
 * Node[] table用来存储键值对数据的
 *
 * 2.假设向哈希表中存储柳岩-18数据，根据柳岩调用String类中重写之后hashCode()方法计算出值，然后结合数组长度采用
 * 某种算法计算出向Node数组中存储数据的空间的索引值。
 * 如果计算出的索引空间没有数据，则直接将柳岩-18存储到数组中。
 * 举例：计算出的索引是3
 *
 *
 * 面试题： 哈希表底层采用何种算法计算Hash的值？还有哪些算法可以计算出hash值？
 * 底层采用key的hashCode方法的值结合数组长度进行无符号右移（>>>）、按位异或（^）、按位与（&）计算出索引。
 * 还可以采用： 平方取中法 、 取余数 、 伪随机数法
 *             10%8---》2 11%8---》3   其他计算方式效率比较低，而位运算效率要高
 *
 * 3.向哈希表中存储数组存储刘德华-40，假设刘德华计算出的hashCode方法结合数组长度出的索引值也是3，那么此时数组
 * 空间不是null，此时底层会比较柳岩和刘德华的hash值是否一致，如果不一致，则在此空间上划出一个节点来存储键值对数据刘德华-40
 *  这种方式成为拉链法
 *
 * 4.假设向哈希表中存储数据柳岩-20，那么首先根据柳岩调用hashCode方法结合数组长度计算出索引值为3，此时比较后
 * 存储的数据柳岩和已经存在的数据的hash值是否相等，如果hash值相等，此时发生hash碰撞。
 * 那底层会调用柳岩所属类String的equal方法比较两个内容是否相等
 *      相等： 则将后添加的数据的value覆盖之前的value
 *      不相等：那么继续向下和其他的数据的key进行比较，如果都不相等，则划出一个节点存储数据
 *
 * 5. 如果节点长度即链表长度大于阈值8并且数组长度大于64则将链表变为红黑树
 */
public class Test1 {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>(10);

        map.put("柳岩", 18);
        map.put("杨幂", 28);
        map.put("刘德华", 40);
        map.put("柳岩", 20);

        System.out.println(map);

        System.out.println(map);

//        hash碰撞
        System.out.println("重地".hashCode()); // 1179395
        System.out.println("通话".hashCode()); // 1179395

        /**
         * 2.面试题： 当两个对象的hashCode相等时会怎样？
         * 会产生哈希碰撞，若key值内容相同则替换旧的value，不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储
         *
         * 3.面试题：何时发生哈希碰撞和什么是哈希碰撞，如何解决哈希碰撞？
         * 只要两个元素的key计算的哈希码值相同就会发生哈希碰撞，jdk8之前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决hash碰撞
         *
         * 4.面试题：如果两个键的hashCode相同，如何存储键值对
         * hashCode相同，通过equals比较内容是否相同
         * 相同：则新的value覆盖之前的value
         * 不相同，则将新的键值对添加到哈希表中
         *
         * 5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空）时，扩容。
         * 默认的扩容方式：扩容为原来的容量的两倍，并将原有的数据复制过来。
         *
         * 6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次
         * 查找的效率较低。而JDK1.8中，哈希表中存储采用数组 + 链表 + 红黑树 （JDK8中增加了红黑树部分）实现的
         */
    }
}
